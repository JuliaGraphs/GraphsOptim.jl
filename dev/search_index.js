var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphsOptim","category":"page"},{"location":"#GraphsOptim","page":"Home","title":"GraphsOptim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GraphsOptim.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [GraphsOptim]","category":"page"},{"location":"#GraphsOptim.GraphsOptim","page":"Home","title":"GraphsOptim.GraphsOptim","text":"GraphsOptim\n\nA package for graph-related optimization algorithms that rely on Linear Programming.\n\n\n\n\n\n","category":"module"},{"location":"#GraphsOptim.MatchingResult","page":"Home","title":"GraphsOptim.MatchingResult","text":"MatchingResult{U}\n\nA type representing the result of a matching algorithm.\n\nFields\n\nweight::U: total weight of the matching\nmate::Vector{Int}: pairwise assignment.\n\nmate[i] = j if vertex i is matched to vertex j, and mate[i] = -1 for unmatched vertices.\n\n\n\n\n\n","category":"type"},{"location":"#GraphsOptim.cutoff_weights-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, R}} where {T<:Real, R<:Real}","page":"Home","title":"GraphsOptim.cutoff_weights","text":"cutoff_weights(w, cutoff)\n\nCopy the weights matrix w with all elements below cutoff set to 0.\n\n\n\n\n\n","category":"method"},{"location":"#GraphsOptim.default_weights-Tuple{G} where G<:Graphs.AbstractGraph","page":"Home","title":"GraphsOptim.default_weights","text":"default_weights(g)\n\nReturn the binary undirected adjacency matrix of g.\n\n\n\n\n\n","category":"method"},{"location":"#GraphsOptim.maximum_weight_matching-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph}, Tuple{U}, Tuple{Graphs.SimpleGraphs.SimpleGraph, AbstractMatrix{U}}} where U<:Real","page":"Home","title":"GraphsOptim.maximum_weight_matching","text":"maximum_weight_matching(g, w; optimizer)\n\nGiven a graph g and an matrix w of edge weights, return a matching  (MatchingResult object) with the maximum total weight.\n\nIf no weight matrix is given, all edges will be considered to have weight 1 (results in max cardinality matching). Edges in g that are not present in w will not be considered for the matching.\n\nA JuMP-compatible solver must be provided with the optimizer argument.\n\nThe efficiency of the algorithm depends on the input graph:\n\nIf the graph is bipartite, then the LP relaxation is integral.\nIf the graph is not bipartite, then it requires a MIP solver and the computation time may grow exponentially.\n\n\n\n\n\n","category":"method"},{"location":"#GraphsOptim.maximum_weight_maximal_matching-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph}, Tuple{T}, Tuple{Graphs.SimpleGraphs.SimpleGraph, AbstractMatrix{T}}} where T<:Real","page":"Home","title":"GraphsOptim.maximum_weight_maximal_matching","text":"maximum_weight_maximal_matching(g, w[, cutoff]; optimizer)\n\nGiven a bipartite graph g and a matrix w of edge weights, return a matching (MatchingResult object) with the maximum total weight among the ones that contain the largest number of edges.\n\nIf no weight matrix is given, all edges will be considered to have weight 1 (results in max cardinality matching). Edges in g that are not present in w will not be considered for the matching.\n\nA JuMP-compatible solver must be provided with the optimizer argument.\n\nA cutoff argument can be given to reduce computation time by excluding edges with weights lower than the specified value.\n\nThe algorithm relies on a linear relaxation on of the matching problem, which is guaranteed to have integer solution on bipartite graphs.\n\n\n\n\n\n","category":"method"},{"location":"#GraphsOptim.minimum_cost_flow-Union{Tuple{AG}, Tuple{Type{Graphs.IsDirected{AG}}, AG, AbstractVector, AbstractMatrix, AbstractMatrix}} where AG<:Graphs.AbstractGraph","page":"Home","title":"GraphsOptim.minimum_cost_flow","text":"minimum_cost_flow(\n    g::AbstractGraph,\n    node_demand::AbstractVector,\n    edge_capacity::AbstractMatrix,\n    edge_cost::AbstractMatrix,\n    optimizer;\n    edge_demand::Union{Nothing,AbstractMatrix} = nothing,\n    source_nodes = (),\n    sink_nodes = ()\n)\n\nFind a flow over a directed graph g satisfying the node_demand at each node and edge_capacity constraints for each edge while minimizing dot(edge_cost, flow).\n\nReturns a sparse flow matrix, flow[i,j] corresponds to the flow on the (i,j) arc.\n\nArguments\n\ng is a directed Graphs.AbstractGraph.\n\n-node_demand is a vector of nodal demand values, which should be negative for sources, positive for sink nodes, and zero for all other nodes.\n\nedge_capacity::AbstractMatrix sets an upper bound on the flow of each arc.\nedge_cost::AbstractMatrix the cost per unit of flow on each arc.\noptimizer is an optimizer constructor, like Clp.Optimizer or () -> Clp.Optimizer() passed at the construction of the JuMP.Model.\n\nKeyword arguments\n\nedge_demand::Union{Nothing,AbstractMatrix}: require a minimum flow for edges, or nothing.\nsource_nodes Collection of sources at which the nodal netflow is allowed to be greater than nodal demand, defaults to an empty tuple.\nsink_nodes Collection of sinks at which the nodal netflow is allowed to be less than nodal demand, defaults to an empty tuple.\n\nsource_nodes & sink_nodes are only needed when nodal flow are not explictly set in node_demand\n\nExamples\n\njulia> import Graphs\njulia> using GraphsFlows: mincost_flow\njulia> import GLPK # use your favorite LP solver here\njulia> using SparseArrays: spzeros\njulia> g = Graphs.DiGraph(6) # Create a flow-graph\njulia> Graphs.add_edge!(g, 5, 1)\njulia> Graphs.add_edge!(g, 5, 2)\njulia> Graphs.add_edge!(g, 3, 6)\njulia> Graphs.add_edge!(g, 4, 6)\njulia> Graphs.add_edge!(g, 1, 3)\njulia> Graphs.add_edge!(g, 1, 4)\njulia> Graphs.add_edge!(g, 2, 3)\njulia> Graphs.add_edge!(g, 2, 4)\njulia> cost = zeros(6,6)\njulia> cost[1,3] = 10\njulia> cost[1,4] = 5\njulia> cost[2,3] = 2\njulia> cost[2,4] = 2\njulia> demand = spzeros(6)\njulia> demand[5] = -2\njulia> demand[6] = 2\njulia> capacity = ones(6,6)\njulia> flow = minimum_cost_flow(g, demand, capacity, cost, optimizer=GLPK.Optimizer)\n\n\n\n\n\n","category":"method"}]
}
