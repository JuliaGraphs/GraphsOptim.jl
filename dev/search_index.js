var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphsOptim","category":"page"},{"location":"#GraphsOptim","page":"Home","title":"GraphsOptim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GraphsOptim.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GraphsOptim]","category":"page"},{"location":"#GraphsOptim.mincost_flow","page":"Home","title":"GraphsOptim.mincost_flow","text":"function mincost_flow(g::AbstractGraph,\n\t\tnode_demand::AbstractVector,\n\t\tedge_capacity::AbstractMatrix,\n\t\tedge_cost::AbstractMatrix,\n\t\toptimizer;\n\t\tedge_demand::Union{Nothing,AbstractMatrix} = nothing,\n\t\tsource_nodes = (),\n\t\tsink_nodes = ()\n\t\t)\n\nFind a flow over a directed graph g satisfying the node_demand at each node and edge_capacity constraints for each edge while minimizing dot(edge_cost, flow).\n\nReturns a sparse flow matrix, flow[i,j] corresponds to the flow on the (i,j) arc.\n\nArguments\n\ng is a directed Graphs.AbstractGraph.\n\n-node_demand is a vector of nodal demand values, which should be negative for sources, positive for sink nodes, and zero for all other nodes.\n\nedge_capacity::AbstractMatrix sets an upper bound on the flow of each arc.\nedge_cost::AbstractMatrix the cost per unit of flow on each arc.\noptimizer is an optimizer constructor, like Clp.Optimizer or () -> Clp.Optimizer() passed at the construction of the JuMP.Model.\n\nKeyword arguments\n\nedge_demand::Union{Nothing,AbstractMatrix}: require a minimum flow for edges, or nothing.\nsource_nodes Collection of sources at which the nodal netflow is allowed to be greater than nodal demand, defaults to an empty tuple.\nsink_nodes Collection of sinks at which the nodal netflow is allowed to be less than nodal demand, defaults to an empty tuple.\n\nsource_nodes & sink_nodes are only needed when nodal flow are not explictly set in node_demand\n\nUsage Example:\n\njulia> import Graphs\njulia> using GraphsFlows: mincost_flow\njulia> import Clp # use your favorite LP solver here\njulia> using SparseArrays: spzeros\njulia> g = Graphs.DiGraph(6) # Create a flow-graph\njulia> Graphs.add_edge!(g, 5, 1)\njulia> Graphs.add_edge!(g, 5, 2)\njulia> Graphs.add_edge!(g, 3, 6)\njulia> Graphs.add_edge!(g, 4, 6)\njulia> Graphs.add_edge!(g, 1, 3)\njulia> Graphs.add_edge!(g, 1, 4)\njulia> Graphs.add_edge!(g, 2, 3)\njulia> Graphs.add_edge!(g, 2, 4)\njulia> cost = zeros(6,6)\njulia> cost[1,3] = 10\njulia> cost[1,4] = 5\njulia> cost[2,3] = 2\njulia> cost[2,4] = 2\njulia> demand = spzeros(6)\njulia> demand[5] = -2\njulia> demand[6] = 2\njulia> capacity = ones(6,6)\njulia> flow = mincost_flow(g, demand, capacity, cost, Clp.Optimizer)\n\n\n\n\n\n","category":"function"}]
}
