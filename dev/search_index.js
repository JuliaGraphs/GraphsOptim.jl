var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GraphsOptim","category":"page"},{"location":"#GraphsOptim","page":"Home","title":"GraphsOptim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GraphsOptim.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [GraphsOptim]","category":"page"},{"location":"#GraphsOptim.GraphsOptim","page":"Home","title":"GraphsOptim.GraphsOptim","text":"GraphsOptim\n\nA package for graph-related optimization algorithms that rely on Linear Programming.\n\n\n\n\n\n","category":"module"},{"location":"#GraphsOptim.minimum_cost_flow","page":"Home","title":"GraphsOptim.minimum_cost_flow","text":"minimum_cost_flow(\n    g, vertex_demand, edge_cost, edge_min_capacity, edge_max_capacity;\n    flowvar_name, integer\n)\n\nCreate a JuMP model, call minimum_cost_flow! to populate it, optimize it and return the optimal flow as a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"#GraphsOptim.minimum_cost_flow!-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, JuMP.Model, G, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractMatrix}} where G<:Graphs.AbstractGraph","page":"Home","title":"GraphsOptim.minimum_cost_flow!","text":"minimum_cost_flow!(\n    model, g, vertex_demand, edge_cost, edge_min_capacity, edge_max_capacity;\n    flowvar_name, integer\n)\n\nModify a JuMP model by adding the variables, constraints and objective necessary to compute a minimum cost flow over a directed graph.\n\nArguments\n\nmodel::JuMP.Model: the optimization model to modify\ng::Graphs.AbstractGraph: a directed graph G = (V E)\nvertex_demand::AbstractVector: a vector d in mathbbR^V giving the flow requested by each vertex (should be positive for sinks, negative for sources and zero elsewhere)\nedge_cost::AbstractMatrix: a vector c in mathbbR^E giving the cost of a unit of flow on each edge\nedge_min_capacity::AbstractMatrix: a vector a in mathbbR^E giving the minimum flow allowed on each edge\nedge_max_capacity::AbstractMatrix: a vector b in mathbbR^E giving the maximum flow allowed on each edge\n\nKeyword arguments\n\nflowvar_name::Symbol: the name of the optimization variable containing the flow\ninteger::Bool: whether the flow should be integer-valued or real-valued\n\nMathematical formulation\n\nThe objective function is\n\nmin_f in mathbbR^E sum_(u v) in E c(u v) f(u v)\n\nThe edge capacity constraint dictates that for all (u v) in E,\n\na(u v) leq f(u v) leq b(u v)\n\nThe flow conservation constraint with node demand dictates that for all v in V,\n\nf^-(v) = d(v) + f^+(v)\n\nwhere the incoming flow f^-(v) and outgoing flow f^+(v) are defined as\n\nf^-(v) = sum_u in N^-(v) f(u v) quad textand quad f^+(v) = sum_w in N^+(v) f(v w)\n\n\n\n\n\n","category":"method"}]
}
